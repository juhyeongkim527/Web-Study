- JS에서는 처음에 html 파일의 소스를 해석할 때, 함수 선언 부를 가장 먼저 해석하기 떄문에, **실행 전에 선언이 되어 있지 않아도 바로 실행 가능**
  
  1. `<!DOCTYPE html>`을 보고 웹 문서라는 것을 인식 후 `<html></html>` 사이의 코드를 HTML 표준에 맞춰 해석

  2. HTML 코드의 포함 관계를 확인, 예를 들어 `<head></head>` 태그 사이, `<body></body>` 태그 사이에 어떤 태그들이 존재하는지, 관계는 어떠한지 확인

  3. css 스타일 정보를 분석

  4. `<script></script>` 태그 내부의 정보를 해석 : 웹 브라우저 안에 포함된 자바스크립트 해석기가 이를 해석해줌
    - 이래서 만약에, <script> 앞에 사용하고자 하는 html 태그가 나와있지 않으면 `null` 값으로 처리 되어 오류가 생기므로, 항상 `<body></body>` 를 닫기 가장 마지막에 `<script></script>` 코드를 삽입

  5. 앞에서 해석한 html 태그 정보와, css 스타일 정보를 통해 웹 브라우저에 화면을 표시

  6. 자바스크립트 코드를 실행

# `var` : `ES6` 이전에 사용하던 변수 선언 방식 - 현재는 사용하지 않을 것을 권장 (`재선언`으로 인한 오류, 의도치 않은 `전역 변수`선언으로 인한 오류 등)

- `var` 키워드는 변수를 선언할 때, `함수 스코핑(function scoping)` 을 지정하는 키워드이다.

- 따라서, `지역 변수`와 완전히 동일한 개념은 아니기 때문에, `if{}`나 `while{}` 블럭 안에서는 `var`를 써도, `지역 변수`가 아닌 `전역 변수`로 선언된다.
  
- 함수 안에서 `var` 키워드를 쓰면 `지역 변수`로 인식되어서, 함수 밖에서 사용할 수 없다.

- 함수 안에서 `var` 키워드를 쓰지 않고 새로 변수를 선언하면, `전역 변수`로 선언된다.

- 함수 밖에서 `var` 키워드를 쓰면 `전역 변수`로 인식되며, 어디서든 사용할 수 있다. `var` 키워드를 쓰는 이유는 명시적으로 변수 선언임을 알리기 위한 것 뿐인듯

- `var` 키워드는 `재할당`과 `재선언`이 가능 : `재선언`은 불가능한 언어가 많지만 자바스크립트에서는 가능하고, 그냥 새로운 값을 할당한 것처럼 동작함

## `Hoisting` : 실제 코드 실행 전에 `var` 변수의 최상단 `scope`로 선언을 끌어올리는 것 (`undefined`로 처음에 초기화)

- 아래의 코드에서, `y`의 선언과 할당이 동시에 이루어져있고, `y`를 선언하기 전에 `console.log("y is" + y);`를 사용하기 때문에 오류가 나야할 것 같지만, `Hoisting` 때문에 오류가 나지 않고 `undefined`가 출력됨

```
console.log("y is" + y);
var y = 30;
```

- 그 이유는, 자바스크립트 해석기는 처음에 `<script>` 태그를 보며 자바스크립트 코드를 해석하는 과정에서 `var` 키워드가 붙은 변수들을 따로 기억해두기 때문에, 실제 코드의 위치는 뒤에 있어도 이미 해당 변수가 선언되어 있는 것처럼, 아래와 같이 동작함\
(실제 코드가 이렇게 변한다는 것이 아니라 동작이 이렇게 된다는 뜻)

```
var y;
console.log("y is" + y);
y = 30;
```

- 따라서, 호이스팅으로 인한 의도치 않은 문제가 발생할 수 있기 떄문에 항상 `var` 변수의 선언은 함수의 가장 앞에 할 것을 권장함

# `let`, `const` : `ES6` 이후 `var`의 문제점으로 인해 등장한 변수 선언 키워드 : `function scoping`가 아닌 `block scoping` 이며, `재선언` 불가능

- `var`과 달리 호이스팅이 적용되지 않기 때문에, 선언하기 전에 변수를 참조하면 오류가 발생

## `let` : 블록 스코핑, 재선언 불가능

- `var` 과 달리 함수 스코핑이 아닌 블록 스코핑이며 재선언이 불가능 하여, `var`의 문제 해결 가능 : 호이스팅, 재선언, 의도치 않은 전역 변수

- 마찬가지로, `ES6` 에서도 전역 변수로 선언하기 위해서는 아무 `keyword`를 붙이지 않으면 됨

## `const` : 블록 스코핑, 재선언 불가능, 상수로 취급되어 재할당도 불가능

- `var` 과 달리 함수 스코핑이 아닌 블록 스코핑이며 재선언이 불가능 하여, `var`의 문제 해결 가능

- 상수로 취급되기 때문에 **선언과 동시에 무조건 할당이 이루어져야 하고,** 선언과 함께 한번 값을 할당한 이후 재할당 불가능

# 각 `keyword`의 차이 정리

1. `var` : `ES6` 이전 버전에서 사용하던 `keyword`로 현재는 `let`으로 대체하여 `var`의 사용을 피하는 것을 권장
  
  - `function scoping` : `if`, `while`, `for` 내부에서 블록 스코핑이 안되는거 유의
  
  - `Hoisiting` : 의도치 않은 오류가 발생할 수 있기 때문에, 함수 내에서 `var`을 쓸 때는 가장 앞에 선언을 해줄 것
  
  - `재할당`, `재선언` 가능 : 의도치 않게 이미 사용중이던 변수를 변경하는 오류 발생 가능성 주의

2. `let`

  - `block scoping`
  
  - `Hoisting` 적용 X
  
  - `재할당`은 가능하지만, `재선언`은 불가능

3. `const`

  - `block scoping`

  - `Hoisting` 적용 X

  - `재할당`, `재선언` 모두 불가능 + 선언시 할당을 동시에 해줘야함
 
# paramter

- 아래와 같이 `ES6` 부터 paramter의 기본값 사용 가능

```
function multiple(a = 10, b = 20, c = 30){
  return a * b * c;
}
```

- `parseInt(null)`은 `NaN`을 리턴하기 때문에, `isNaN`이나 `number != NaN`로 검사해야함

### 문자형과 정수형의 비교는 항상 문자형을 정수형으로 변환하여 이루어짐

- 문자형과 정수형를 비교할 때, 문자형이 숫자값으로 변환될 수 있다면 정수형으로 변환되어 계산됨
  - ex) "10" < 11 : `true`
  - "10"이 `Number("10");` 으로 계산되기 때문

- 문자형과 정수형을 비교할 때, 문자형이 숫자값으로 변환될 수 없다면 문자형이 `NaN`으로 변환되어 항상 `false`가 나옴
  - ex) "A" < 11 : `false`
  - "A"가 `Number("A");` 으로 계산되면 `NaN`을 리턴하기 떄문
 
# 익명 함수

```
function(매개변수)
{
  body;
}
```

형태로 쓰이고, 변수에 할당 하여 사용 가능

# 즉시 실행 함수

```
(function(매개변수)
{
  body;
}(매개변수));
```

형태로 쓰이고, 단독으로 사용도 가능하며, 변수에 할당 하여 재사용 하는 것은 불가능

# 화살표 함수 : `ES6` 버전부터 사용 가능

- 익명 함수에서만 사용 가능

- `let 변수명 = (매개변수) => {body;};` 으로 사용 가능하고, 매개 변수가 하나인 경우에는 `()`이 생략 가능하며, `body;`가 한줄인 경우에는 `{}`를 생략 가능
